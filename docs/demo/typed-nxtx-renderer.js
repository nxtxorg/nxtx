(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.nxtx = factory());
}(this, function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var parser = /*
     * Generated by PEG.js 0.10.0.
     *
     * http://pegjs.org/
     */
    (function() {

      function peg$subclass(child, parent) {
        function ctor() { this.constructor = child; }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }

      function peg$SyntaxError(message, expected, found, location) {
        this.message  = message;
        this.expected = expected;
        this.found    = found;
        this.location = location;
        this.name     = "SyntaxError";

        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }

      peg$subclass(peg$SyntaxError, Error);

      peg$SyntaxError.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return "\"" + literalEscape(expectation.text) + "\"";
              },

              "class": function(expectation) {
                var escapedParts = "",
                    i;

                for (i = 0; i < expectation.parts.length; i++) {
                  escapedParts += expectation.parts[i] instanceof Array
                    ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                    : classEscape(expectation.parts[i]);
                }

                return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
              },

              any: function(expectation) {
                return "any character";
              },

              end: function(expectation) {
                return "end of input";
              },

              other: function(expectation) {
                return expectation.description;
              }
            };

        function hex(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }

        function literalEscape(s) {
          return s
            .replace(/\\/g, '\\\\')
            .replace(/"/g,  '\\"')
            .replace(/\0/g, '\\0')
            .replace(/\t/g, '\\t')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
        }

        function classEscape(s) {
          return s
            .replace(/\\/g, '\\\\')
            .replace(/\]/g, '\\]')
            .replace(/\^/g, '\\^')
            .replace(/-/g,  '\\-')
            .replace(/\0/g, '\\0')
            .replace(/\t/g, '\\t')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
        }

        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }

        function describeExpected(expected) {
          var descriptions = new Array(expected.length),
              i, j;

          for (i = 0; i < expected.length; i++) {
            descriptions[i] = describeExpectation(expected[i]);
          }

          descriptions.sort();

          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }

          switch (descriptions.length) {
            case 1:
              return descriptions[0];

            case 2:
              return descriptions[0] + " or " + descriptions[1];

            default:
              return descriptions.slice(0, -1).join(", ")
                + ", or "
                + descriptions[descriptions.length - 1];
          }
        }

        function describeFound(found) {
          return found ? "\"" + literalEscape(found) + "\"" : "end of input";
        }

        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };

      function peg$parse(input, options) {
        options = options !== void 0 ? options : {};

        var peg$FAILED = {},

            peg$startRuleFunctions = { Paragraphs: peg$parseParagraphs },
            peg$startRuleFunction  = peg$parseParagraphs,

            peg$c0 = function(head, tail) { return [head, ...tail] },
            peg$c1 = function(head) { return [head] },
            peg$c2 = function(chain) { return { type: TYPE.PARAGRAPH, value: chain, location: location() } },
            peg$c3 = peg$otherExpectation("paragraph"),
            peg$c4 = peg$otherExpectation("text"),
            peg$c5 = function(text) { return { type: TYPE.TEXT, value: text.join('') } },
            peg$c6 = "\\\\",
            peg$c7 = peg$literalExpectation("\\\\", false),
            peg$c8 = function() { return '\\' },
            peg$c9 = /^[^\r\n\\]/,
            peg$c10 = peg$classExpectation(["\r", "\n", "\\"], true, false),
            peg$c11 = function() { return text() },
            peg$c12 = peg$otherExpectation("command"),
            peg$c13 = "\\",
            peg$c14 = peg$literalExpectation("\\", false),
            peg$c15 = function(name, args) { return { type: TYPE.COMMAND, name, args: args || [] } },
            peg$c16 = peg$otherExpectation("command name"),
            peg$c17 = /^[_:\-]/,
            peg$c18 = peg$classExpectation(["_", ":", "-"], false, false),
            peg$c19 = /^[a-zA-Z!#-&*-+\--\/;-@]/,
            peg$c20 = peg$classExpectation([["a", "z"], ["A", "Z"], "!", ["#", "&"], ["*", "+"], ["-", "/"], [";", "@"]], false, false),
            peg$c21 = /^[0-9]/,
            peg$c22 = peg$classExpectation([["0", "9"]], false, false),
            peg$c23 = "(",
            peg$c24 = peg$literalExpectation("(", false),
            peg$c25 = ")",
            peg$c26 = peg$literalExpectation(")", false),
            peg$c27 = function(args) { return args },
            peg$c28 = /^[^)]/,
            peg$c29 = peg$classExpectation([")"], true, false),
            peg$c30 = function(args) { return [ { type: TYPE.STRING, value: args.join('') }] },
            peg$c31 = peg$otherExpectation("command arguments"),
            peg$c32 = ",",
            peg$c33 = peg$literalExpectation(",", false),
            peg$c34 = peg$otherExpectation("name"),
            peg$c35 = function(name) { return { type: TYPE.STRING, value: name } },
            peg$c36 = peg$otherExpectation("number"),
            peg$c37 = ".",
            peg$c38 = peg$literalExpectation(".", false),
            peg$c39 = function(float) { return { type: TYPE.NUMBER, value: (float ? parseFloat(text()) : parseInt(text(), 10)) } },
            peg$c40 = peg$otherExpectation("string"),
            peg$c41 = "\"",
            peg$c42 = peg$literalExpectation("\"", false),
            peg$c43 = /^[^"]/,
            peg$c44 = peg$classExpectation(["\""], true, false),
            peg$c45 = function(text) { return { type: TYPE.STRING, value: text.join('') } },
            peg$c46 = "'",
            peg$c47 = peg$literalExpectation("'", false),
            peg$c48 = /^[^']/,
            peg$c49 = peg$classExpectation(["'"], true, false),
            peg$c50 = peg$otherExpectation("array"),
            peg$c51 = "[",
            peg$c52 = peg$literalExpectation("[", false),
            peg$c53 = "]",
            peg$c54 = peg$literalExpectation("]", false),
            peg$c55 = function(chain) { return { type: TYPE.ARRAY, value: chain } },
            peg$c56 = function() { return { type: TYPE.ARRAY, value: [] } },
            peg$c57 = peg$otherExpectation("dictionary"),
            peg$c58 = "{",
            peg$c59 = peg$literalExpectation("{", false),
            peg$c60 = "}",
            peg$c61 = peg$literalExpectation("}", false),
            peg$c62 = function(pairs) { return { type: TYPE.DICTIONARY, value: pairs.reduce((acc, e) => (acc[e.name] = e.value) && acc, {}) } },
            peg$c63 = function() { return { type: TYPE.DICTIONARY, value: {} } },
            peg$c64 = peg$otherExpectation("key-value pair(s)"),
            peg$c65 = peg$otherExpectation("key-value pair"),
            peg$c66 = ":",
            peg$c67 = peg$literalExpectation(":", false),
            peg$c68 = function(name, value) { return { name, value } },
            peg$c69 = function(name, value) { return { key: name.value, value } },
            peg$c70 = peg$otherExpectation("newline"),
            peg$c71 = "\r\n",
            peg$c72 = peg$literalExpectation("\r\n", false),
            peg$c73 = "\r",
            peg$c74 = peg$literalExpectation("\r", false),
            peg$c75 = "\n",
            peg$c76 = peg$literalExpectation("\n", false),
            peg$c77 = peg$otherExpectation("optional inline whitespace"),
            peg$c78 = /^[ \t]/,
            peg$c79 = peg$classExpectation([" ", "\t"], false, false),
            peg$currPos          = 0,
            peg$savedPos         = 0,
            peg$posDetailsCache  = [{ line: 1, column: 1 }],
            peg$maxFailPos       = 0,
            peg$maxFailExpected  = [],
            peg$silentFails      = 0,

            peg$result;

        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
          }

          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }

        function text() {
          return input.substring(peg$savedPos, peg$currPos);
        }

        function location() {
          return peg$computeLocation(peg$savedPos, peg$currPos);
        }

        function peg$literalExpectation(text, ignoreCase) {
          return { type: "literal", text: text, ignoreCase: ignoreCase };
        }

        function peg$classExpectation(parts, inverted, ignoreCase) {
          return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
        }

        function peg$endExpectation() {
          return { type: "end" };
        }

        function peg$otherExpectation(description) {
          return { type: "other", description: description };
        }

        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos], p;

          if (details) {
            return details;
          } else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
              p--;
            }

            details = peg$posDetailsCache[p];
            details = {
              line:   details.line,
              column: details.column
            };

            while (p < pos) {
              if (input.charCodeAt(p) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }

              p++;
            }

            peg$posDetailsCache[pos] = details;
            return details;
          }
        }

        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos),
              endPosDetails   = peg$computePosDetails(endPos);

          return {
            start: {
              offset: startPos,
              line:   startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line:   endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }

        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) { return; }

          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }

          peg$maxFailExpected.push(expected);
        }

        function peg$buildStructuredError(expected, found, location) {
          return new peg$SyntaxError(
            peg$SyntaxError.buildMessage(expected, found),
            expected,
            found,
            location
          );
        }

        function peg$parseParagraphs() {
          var s0, s1, s2, s3, s4, s5;

          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseNEWLINE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseNEWLINE();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseParagraph();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseNEWLINE();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseNEWLINE();
                if (s5 !== peg$FAILED) {
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseNEWLINE();
                  }
                } else {
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseParagraphs();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c0(s2, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseNEWLINE();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseNEWLINE();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseParagraph();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseNEWLINE();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseNEWLINE();
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c1(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }

          return s0;
        }

        function peg$parseParagraph() {
          var s0, s1;

          s0 = peg$currPos;
          s1 = peg$parseParagraphChain();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1);
          }
          s0 = s1;

          return s0;
        }

        function peg$parseParagraphChain() {
          var s0, s1, s2, s3;

          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseLineContent();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNEWLINE();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseParagraphChain();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c0(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseLineContent();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c1(s1);
            }
            s0 = s1;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c3); }
          }

          return s0;
        }

        function peg$parseLineContent() {
          var s0;

          s0 = peg$parseCommand();
          if (s0 === peg$FAILED) {
            s0 = peg$parseText();
          }

          return s0;
        }

        function peg$parseText() {
          var s0, s1, s2;

          peg$silentFails++;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseTextContent();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseTextContent();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s1);
          }
          s0 = s1;
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c4); }
          }

          return s0;
        }

        function peg$parseTextContent() {
          var s0, s1, s2;

          peg$silentFails++;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c6) {
            s1 = peg$c6;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c7); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c8();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            if (peg$c9.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c10); }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$c9.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c10); }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c11();
            }
            s0 = s1;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c4); }
          }

          return s0;
        }

        function peg$parseCommand() {
          var s0, s1, s2, s3;

          peg$silentFails++;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c13;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseCommandName();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseCommandArguments();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c15(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c12); }
          }

          return s0;
        }

        function peg$parseCommandName() {
          var s0, s1, s2, s3;

          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseCommandChars();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseCommandName();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c11();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseCommandChars();
            if (s1 !== peg$FAILED) {
              if (peg$c17.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c18); }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseCommandName();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c11();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseCommandChars();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11();
              }
              s0 = s1;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c16); }
          }

          return s0;
        }

        function peg$parseCommandChars() {
          var s0, s1, s2;

          s0 = peg$currPos;
          if (peg$c19.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c20); }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c21.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c22); }
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          return s0;
        }

        function peg$parseCommandArguments() {
          var s0, s1, s2, s3, s4, s5;

          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c23;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c24); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseValueChain();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c25;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c26); }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c27(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
              s1 = peg$c23;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c24); }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              if (peg$c28.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c29); }
              }
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  if (peg$c28.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c29); }
                  }
                }
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s3 = peg$c25;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c26); }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c30(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }

          return s0;
        }

        function peg$parseValueChain() {
          var s0, s1, s2, s3, s4, s5, s6, s7;

          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseValue();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s3 = peg$c32;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c33); }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseNEWLINE();
                  if (s5 === peg$FAILED) {
                    s5 = null;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseValueChain();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c0(s1, s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseValue();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c1(s1);
            }
            s0 = s1;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c31); }
          }

          return s0;
        }

        function peg$parseValue() {
          var s0;

          s0 = peg$parseDictionary();
          if (s0 === peg$FAILED) {
            s0 = peg$parseArray();
            if (s0 === peg$FAILED) {
              s0 = peg$parseCommand();
              if (s0 === peg$FAILED) {
                s0 = peg$parseName();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseNumber();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseString();
                  }
                }
              }
            }
          }

          return s0;
        }

        function peg$parseName() {
          var s0, s1;

          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseCommandName();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c35(s1);
          }
          s0 = s1;
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }

          return s0;
        }

        function peg$parseNumber() {
          var s0, s1, s2, s3, s4, s5;

          peg$silentFails++;
          s0 = peg$currPos;
          s1 = [];
          if (peg$c21.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c22); }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              if (peg$c21.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c22); }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c37;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c38); }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              if (peg$c21.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c22); }
              }
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  if (peg$c21.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c22); }
                  }
                }
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c39(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }

          return s0;
        }

        function peg$parseString() {
          var s0, s1, s2, s3;

          peg$silentFails++;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c41;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c42); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c43.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c44); }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c43.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c44); }
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c41;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c42); }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c45(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 39) {
              s1 = peg$c46;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c47); }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              if (peg$c48.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c49); }
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c48.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c49); }
                }
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s3 = peg$c46;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c47); }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c45(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c40); }
          }

          return s0;
        }

        function peg$parseArray() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

          peg$silentFails++;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c51;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c52); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseNEWLINE();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseValueChain();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseNEWLINE();
                      if (s7 === peg$FAILED) {
                        s7 = null;
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parse_();
                        if (s8 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 93) {
                            s9 = peg$c53;
                            peg$currPos++;
                          } else {
                            s9 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c54); }
                          }
                          if (s9 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c55(s5);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c51;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c52); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c53;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c54); }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c56();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c50); }
          }

          return s0;
        }

        function peg$parseDictionary() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

          peg$silentFails++;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c58;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c59); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseNEWLINE();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseKeyValuePairs();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseNEWLINE();
                      if (s7 === peg$FAILED) {
                        s7 = null;
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parse_();
                        if (s8 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 125) {
                            s9 = peg$c60;
                            peg$currPos++;
                          } else {
                            s9 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c61); }
                          }
                          if (s9 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c62(s5);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 123) {
              s1 = peg$c58;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c59); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s3 = peg$c60;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c61); }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c63();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c57); }
          }

          return s0;
        }

        function peg$parseKeyValuePairs() {
          var s0, s1, s2, s3, s4, s5;

          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseKeyValuePair();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseNEWLINE();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseKeyValuePairs();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c0(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseKeyValuePair();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s3 = peg$c32;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c33); }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseKeyValuePairs();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c0(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseKeyValuePair();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c1(s1);
              }
              s0 = s1;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c64); }
          }

          return s0;
        }

        function peg$parseKeyValuePair() {
          var s0, s1, s2, s3, s4, s5;

          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseCommandName();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s3 = peg$c66;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c67); }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseValue();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c68(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseString();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s3 = peg$c66;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c67); }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseValue();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c69(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c65); }
          }

          return s0;
        }

        function peg$parseNEWLINE() {
          var s0;

          peg$silentFails++;
          if (input.substr(peg$currPos, 2) === peg$c71) {
            s0 = peg$c71;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c72); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 13) {
              s0 = peg$c73;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c74); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s0 = peg$c75;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c76); }
              }
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) { peg$fail(peg$c70); }
          }

          return s0;
        }

        function peg$parse_() {
          var s0, s1;

          peg$silentFails++;
          s0 = [];
          if (peg$c78.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c79); }
          }
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$c78.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c79); }
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c77); }
          }

          return s0;
        }


            const TYPE = { PARAGRAPH: 1, COMMAND: 2, TEXT: 3, DICTIONARY: 11, ARRAY: 12, NUMBER: 13, STRING: 14 };


        peg$result = peg$startRuleFunction();

        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
          }

          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input.length
              ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
              : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }

      return {
        SyntaxError: peg$SyntaxError,
        parse:       peg$parse
      };
    })();

    var parser$1 = parser;
    console.log(parser$1);

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var errors = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

    function customError(fn, BaseError) {
      BaseError = BaseError || Error;

      function CustomError() {
        // eslint-disable-next-line no-proto
        var _this = CustomError.__proto__.apply(this, arguments);
        Object.assign(_this, fn.apply(null, arguments));
        return _this;
      }

      Object.setPrototypeOf(CustomError, BaseError);

      return CustomError;
    }

    var SubError = exports.SubError = customError(function (errors) {
      var multiStack = errors.reduce(function (str, error) {
        str += '\n\n' + error.stack;
        return str;
      }, '');

      return {
        name: 'SubError',
        message: 'SubError ' + multiStack,
        errors: errors
      };
    }, Error);

    var IterableError = exports.IterableError = customError(function (value) {
      var type = value === null ? 'null' : typeof value === 'undefined' ? 'undefined' : _typeof(value);

      return {
        name: 'IterableError',
        message: 'expecting an array or an iterable object but got ' + type
      };
    }, TypeError);
    });

    unwrapExports(errors);
    var errors_1 = errors.SubError;
    var errors_2 = errors.IterableError;

    var utils = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.size = size;
    exports.repeat = repeat;
    exports.toArray = toArray;
    exports.toBoolean = toBoolean;
    exports.identity = identity;
    exports.defaults = defaults;
    exports.isIterable = isIterable;
    exports.noop = noop;
    exports.isDefined = isDefined;
    function size(obj) {
      return Array.isArray(obj) ? obj.length : Object.keys(obj).length;
    }

    function repeat(count, fn) {
      // eslint-disable-next-line no-plusplus
      for (var i = 0; i < count; i++) {
        fn(i);
      }
    }

    function toArray(obj) {
      return Object.keys(obj).map(function (i) {
        return obj[i];
      });
    }

    function toBoolean(val) {
      return !!val;
    }

    function identity(value) {
      return value;
    }

    function defaults(obj, defaultObj) {
      var initial = Object.assign({}, defaultObj);
      return Object.keys(obj).reduce(function (results, key) {
        results[key] = obj[key] === undefined ? defaultObj[key] : obj[key];
        return results;
      }, initial);
    }

    function isIterable(iterable) {
      return iterable && typeof iterable.entries === 'function';
    }

    function noop() {}

    function isDefined(val) {
      return val !== undefined;
    }
    });

    unwrapExports(utils);
    var utils_1 = utils.size;
    var utils_2 = utils.repeat;
    var utils_3 = utils.toArray;
    var utils_4 = utils.toBoolean;
    var utils_5 = utils.identity;
    var utils_6 = utils.defaults;
    var utils_7 = utils.isIterable;
    var utils_8 = utils.noop;
    var utils_9 = utils.isDefined;

    var resolveAll_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = resolveAll;





    function resolve(promises) {
      return Array.isArray(promises) ? Promise.all(promises) : Promise.resolve(promises);
    }

    function resolveAll(promises) {
      var rejectNonIterable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      return resolve(promises).then(function (resolved) {
        if (rejectNonIterable && !(0, utils.isIterable)(resolved)) {
          return Promise.reject((0, errors.IterableError)(resolved));
        }

        return resolved;
      });
    }
    });

    unwrapExports(resolveAll_1);

    var map_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = map;



    var _resolveAll2 = _interopRequireDefault(resolveAll_1);



    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function map(iterable) {
      var mapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : utils.identity;

      return (0, _resolveAll2.default)(iterable).then(function (values) {
        return Promise.all(values.map(mapper));
      });
    }
    });

    var map = unwrapExports(map_1);

    var series_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = series;
    function series(reducer, initial) {
      return function (iterable) {
        return iterable.reduce(function (chain, value, key) {
          return chain.then(function (results) {
            return reducer(results, value, key, iterable);
          });
        }, Promise.resolve(initial));
      };
    }
    });

    unwrapExports(series_1);

    var mapSeries_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = mapSeries;



    var _series2 = _interopRequireDefault(series_1);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function mapSeries(iterable, mapper) {
      return Promise.all(iterable).then((0, _series2.default)(function (results, value, key, values) {
        return Promise.resolve(value).then(function (resolved) {
          return mapper(resolved, key, values);
        }).then(function (resolved) {
          results.push(resolved);
          return results;
        });
      }, []));
    }
    });

    var mapSeries = unwrapExports(mapSeries_1);

    var reduce_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = reduce;



    var _series2 = _interopRequireDefault(series_1);



    var _resolveAll2 = _interopRequireDefault(resolveAll_1);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function reduce(iterable, reducer, initial) {
      return (0, _resolveAll2.default)(iterable).then((0, _series2.default)(reducer, initial));
    }
    });

    var reduce = unwrapExports(reduce_1);

    var NodeType;
    (function (NodeType) {
        NodeType[NodeType["Paragraph"] = 1] = "Paragraph";
        NodeType[NodeType["Command"] = 2] = "Command";
        NodeType[NodeType["Text"] = 3] = "Text";
        NodeType[NodeType["Block"] = 4] = "Block";
        NodeType[NodeType["Html"] = 5] = "Html";
        NodeType[NodeType["Node"] = 6] = "Node";
        NodeType[NodeType["Dictionary"] = 11] = "Dictionary";
        NodeType[NodeType["Array"] = 12] = "Array";
        NodeType[NodeType["Number"] = 13] = "Number";
        NodeType[NodeType["String"] = 14] = "String";
    })(NodeType || (NodeType = {}));
    //# sourceMappingURL=nxtx-types.js.map

    var _this = undefined;
    var commands = {};
    var preprocessors = {};
    var executeCommand = function (cmd, args) { return __awaiter(_this, void 0, void 0, function () {
        var _a, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    if (!(commands[cmd] !== undefined)) return [3, 3];
                    _b = (_a = commands[cmd]).apply;
                    _c = [commands];
                    return [4, map(args, function (arg) { return arg.type === NodeType.Command ? executeCommand(arg.name, arg.args) : arg; })];
                case 1: return [4, _b.apply(_a, _c.concat([(_d.sent())]))];
                case 2: return [2, _d.sent()];
                case 3:
                    console.warn("Command '" + cmd + "' not registered");
                    return [4, html('b', { class: "error" }, cmd + "?")];
                case 4: return [2, _d.sent()];
            }
        });
    }); };
    var register = function (cmdCollection, cmd, fn, overwrite) {
        if (overwrite === void 0) { overwrite = false; }
        if (!overwrite && cmdCollection[cmd] !== undefined)
            return console.warn("Command '" + cmd + "' is already registered. Set overwrite to true, if you need to overwrite the already registered command.");
        cmdCollection[cmd] = fn;
    };
    var registerCommand = function (cmd, fn, overwrite) { return register(commands, cmd, fn, overwrite); };
    var registerPreprocessor = function (cmd, fn, overwrite) { return register(preprocessors, cmd, fn, overwrite); };
    var verifyArguments = function (types) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var invalidArguments = args
            .map(function (actual, index) { return ({ expected: types[index], actual: actual.type, index: index }); })
            .filter(function (type) { return type.expected !== type.actual; });
        return { ok: invalidArguments.length === 0, invalid: invalidArguments };
    };
    var parse = function (text) { return parser$1.parse(text).map(mergeText); };
    var noMerge = { '.': true, ',': true };
    var mergeText = function (paragraph) {
        var textNodes = [];
        var mergedNodes = paragraph.value.reduce(function (acc, node) {
            if (node.type === NodeType.Text) {
                if (noMerge[node.value[0]]) {
                    acc.push({ type: NodeType.Text, value: node.value[0] + ' ' });
                    if (node.value.length !== 1)
                        textNodes.push({ type: NodeType.Text, value: node.value.substr(1) });
                }
                else
                    textNodes.push(node);
            }
            else {
                if (textNodes.length) {
                    acc.push({ type: NodeType.Text, value: textNodes.map(function (n) { return n.value; }).join(' ') });
                    textNodes.length = 0;
                }
                acc.push(node);
            }
            return acc;
        }, []);
        if (textNodes.length)
            mergedNodes.push({ type: NodeType.Text, value: textNodes.map(function (n) { return n.value; }).join(' ') });
        return { type: paragraph.type, value: mergedNodes };
    };
    var truthy = function (e) { return !!e; };
    var flatMap = function (elements, fn) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, map(elements, fn)];
            case 1: return [2, (_a.sent()).flat()];
        }
    }); }); };
    var flatMapFilter = function (elements, fn) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, map(elements, fn)];
            case 1: return [2, (_a.sent()).flat().filter(truthy)];
        }
    }); }); };
    var baseRenderNode = function (node) { return __awaiter(_this, void 0, void 0, function () {
        var _a, pNodes, result;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (typeof node === 'string')
                        return [2, text(node)];
                    if (!node.type)
                        return [2, node];
                    _a = node.type;
                    switch (_a) {
                        case NodeType.Node: return [3, 1];
                        case NodeType.Paragraph: return [3, 2];
                        case NodeType.Html: return [3, 4];
                        case NodeType.Text: return [3, 5];
                        case NodeType.Command: return [3, 6];
                    }
                    return [3, 9];
                case 1: return [2, node];
                case 2: return [4, flatMap(node.value, baseRenderNode)];
                case 3:
                    pNodes = _b.sent();
                    if (pNodes.length)
                        pNodes.push(htmlLite('div', { class: 'meta paragraph-break' }));
                    return [2, pNodes];
                case 4: return [2, htmlLite('span', { innerHTML: node.value })];
                case 5: return [2, document.createTextNode(node.value)];
                case 6: return [4, executeCommand(node.name, node.args)];
                case 7:
                    result = [_b.sent()].flat().filter(truthy);
                    return [4, flatMap(result, baseRenderNode)];
                case 8: return [2, _b.sent()];
                case 9:
                    console.error(node);
                    return [2];
            }
        });
    }); };
    var flattenNodes = function (nodes) {
        var cleanParagraph;
        var requiresNew = true;
        return nodes.reduce(function (flattened, current) {
            if (current.type === NodeType.Paragraph)
                requiresNew = flattened.push.apply(flattened, flattenNodes(current.value)) && true;
            else {
                if (requiresNew)
                    requiresNew = flattened.push(cleanParagraph = { type: NodeType.Paragraph, value: [] }) && false;
                cleanParagraph.value.push(current);
            }
            return flattened;
        }, []).flat();
    };
    var executePreprocessor = function (node) { return __awaiter(_this, void 0, void 0, function () {
        var result, childResults, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!(node.type === NodeType.Command && preprocessors[node.name])) return [3, 3];
                    return [4, preprocessors[node.name].apply(preprocessors, node.args)];
                case 1:
                    result = [_b.sent()].flat().filter(truthy);
                    return [4, flatMap(result, executePreprocessor)];
                case 2:
                    childResults = _b.sent();
                    if (commands[node.name] === undefined)
                        return [2, childResults];
                    return [3, 5];
                case 3:
                    if (!(node.type === NodeType.Paragraph)) return [3, 5];
                    _a = node;
                    return [4, flatMapFilter(node.value, executePreprocessor)];
                case 4:
                    _a.value = _b.sent();
                    _b.label = 5;
                case 5: return [2, node];
            }
        });
    }); };
    var executePreprocessors = function (paragraphs) { return __awaiter(_this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, reduce(paragraphs, function (processed, current) { return __awaiter(_this, void 0, void 0, function () {
                        var preprocessed;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, flatMapFilter(current.value, executePreprocessor)];
                                case 1:
                                    preprocessed = _a.sent();
                                    processed.push.apply(processed, flattenNodes(preprocessed));
                                    return [2, processed];
                            }
                        });
                    }); }, [])];
                case 1: return [2, _a.sent()];
            }
        });
    }); };
    var render = function (text, root) { return __awaiter(_this, void 0, void 0, function () {
        var page, currentPage, newPage, place, paragraphs, preprocessed, rendered;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    while (root.firstChild)
                        root.removeChild(root.firstChild);
                    page = 0;
                    newPage = function () {
                        root.appendChild(currentPage = htmlLite('section', { id: "page-" + ++page, class: 'sheet', 'data-page': page }));
                        currentPage.appendChild(htmlLite('div', { class: 'meta page-start' }));
                    };
                    newPage();
                    place = function (node) {
                        currentPage.appendChild(node);
                        if (currentPage.scrollHeight > currentPage.clientHeight) {
                            newPage();
                            currentPage.appendChild(node);
                        }
                    };
                    trigger('prerender');
                    paragraphs = parse(text).map(mergeText);
                    return [4, executePreprocessors(paragraphs)];
                case 1:
                    preprocessed = _a.sent();
                    return [4, mapSeries(preprocessed, function (node) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, baseRenderNode(node)];
                                case 1: return [2, _a.sent()];
                            }
                        }); }); })];
                case 2:
                    rendered = _a.sent();
                    rendered.forEach(function (nodes) { return nodes.forEach(place); });
                    trigger('postrender');
                    return [2];
            }
        });
    }); };
    var text = function (content) {
        return document.createTextNode(content);
    };
    var htmlLite = function (nodeName, attributes) {
        var n = document.createElement(nodeName);
        Object.keys(attributes || {}).forEach(function (k) { return n.setAttribute(k, attributes[k]); });
        return n;
    };
    var html = function (nodeName, attributes) {
        var children = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            children[_i - 2] = arguments[_i];
        }
        return __awaiter(_this, void 0, void 0, function () {
            var n, i, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        n = htmlLite(nodeName, attributes);
                        i = 0;
                        _c.label = 1;
                    case 1:
                        if (!(i < children.length)) return [3, 4];
                        _b = (_a = n).appendChild;
                        return [4, baseRenderNode(children[i])];
                    case 2:
                        _b.apply(_a, [_c.sent()]);
                        _c.label = 3;
                    case 3:
                        i++;
                        return [3, 1];
                    case 4: return [2, n];
                }
            });
        });
    };
    var hooks = { prerender: [], postrender: [] };
    var trigger = function (event) { return (hooks[event] || []).forEach(function (fn) { return fn(); }); };
    var on = function (event, handler) {
        if (!hooks[event].includes(handler))
            hooks[event].push(handler);
    };
    var off = function (event, handler) {
        var index = hooks[event].indexOf(handler);
        if (index !== -1)
            hooks[event].splice(index, 1);
    };
    var nxtx = {
        registerCommand: registerCommand,
        registerPreprocessor: registerPreprocessor,
        verifyArguments: verifyArguments,
        parse: parse,
        render: render,
        text: text,
        htmlLite: htmlLite,
        html: html,
        off: off,
        on: on
    };

    return nxtx;

}));
//# sourceMappingURL=typed-nxtx-renderer.js.map
